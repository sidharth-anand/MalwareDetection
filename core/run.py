import glob
import inspect
import importlib
import os
import typing

from core.dataset import Dataset
from core.model import Model
from core.resizer import Resizer
from core.sampler import Sampler

def get_import_choices(dir: str) -> typing.List[str]:
    choices = list(glob.glob(f'{dir}/*.py'))
    choices = [os.path.basename(choice).split('.')[0] for choice in choices]
    return choices

def get_imported_class(filename: str, base_class: typing.Type, indirect = False) -> typing.Type:
    if filename == '':
        return None

    module = importlib.import_module(filename)
    classes = inspect.getmembers(module, inspect.isclass)

    for _, cls in classes:
        if issubclass(cls, base_class) and cls != base_class and (not indirect or base_class != cls.mro()[1]):
            return cls


    raise Exception(f'Could not find a exported class in {filename} which is a subclass of {base_class}')

def override_sampler_choice(output_channels: int, input_channels: int, sampler_choice: str) -> str:
    if not sampler_choice == 'raw':
        return sampler_choice
    
    if output_channels == 1 and input_channels == 3:
        print('You have chosen to not resample the channels in your image, but the model expects 3 channels and the dataset has 1. The default upsampler will be applied.')
        return 'upsampler'
    elif output_channels == 3 and input_channels == 1:
        print('You have chosen to not resample the channels in your image, but the model expects 1 channel and the dataset has 3. The default downsampler will be applied.')
        return 'downsampler'
    
    return 'raw'

def validate_sampler_choice(convert_output_channels: int, model_input_channels: int, sampler_class: typing.Type) -> None:
    if sampler_class.INPUT_CHANNELS == 0:
        sampler_class.INPUT_CHANNELS = convert_output_channels
    if sampler_class.OUTPUT_CHANNELS == 0:
        sampler_class.OUTPUT_CHANNELS = convert_output_channels
    
    if sampler_class.OUTPUT_CHANNELS != model_input_channels or sampler_class.INPUT_CHANNELS != convert_output_channels:
        raise Exception(f'Unable to use the sampler class {sampler_class.__name__} with the given converter/model. The model expects {model_input_channels} channels and the converter returns {convert_output_channels} channels.')

def get_classes(converter: str, model: str, resizer: str, sampler: str, resolution: int) -> typing.Tuple[typing.Type, typing.Type, typing.Type, typing.Type]:
    ConverterClass = get_imported_class(f'converters.{converter}', Dataset, indirect=True)
    ModelClass = get_imported_class(f'models.{model}', Model)
    ResizerClass = get_imported_class(f'resizers.{resizer}', Resizer)


    if hasattr(ModelClass, 'ALLOW_RESIZE') and ModelClass.ALLOW_RESIZE == True:
        ModelClass.INPUT_SIZE = (resolution, resolution)

    sampler = override_sampler_choice(ConverterClass.OUTPUT_CHANNELS, ModelClass.INPUT_CHANNELS, sampler)
    SamplerClass = get_imported_class(f'samplers.{sampler}', Sampler)
    
    validate_sampler_choice(ConverterClass.OUTPUT_CHANNELS, ModelClass.INPUT_CHANNELS, SamplerClass)

    return (ConverterClass, ModelClass, ResizerClass, SamplerClass)
