import typing

import numpy as np
import tensorflow as tf

from core.model import Model

MODEL_URLS = {
    "convnext_tiny_224": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_tiny_1k_224_ema.h5",
    "convnext_small_224": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_small_1k_224_ema.h5",
    "convnext_base_224": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_base_22k_1k_224.h5",
    "convnext_base_384": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_base_22k_1k_384.h5",
    "convnext_large_224": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_large_22k_1k_224.h5",
    "convnext_large_384": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_large_22k_1k_384.h5",
    "convnext_xlarge_224": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_xlarge_22k_1k_224_ema.h5",
    "convnext_xlarge_384": "https://github.com/bamps53/convnext-tf/releases/download/v0.1/convnext_xlarge_22k_1k_384_ema.h5",
}

MODEL_CONFIG = dict(
    convnext_tiny=dict(
        depths=[3, 3, 9, 3],
        dims=[96, 192, 384, 768]
    ),
    convnext_small=dict(
        depths=[3, 3, 27, 3],
        dims=[96, 192, 384, 768]
    ),
    convnext_base=dict(
        depths=[3, 3, 27, 3],
        dims=[128, 256, 512, 1024]
    ),
    convnext_large=dict(
        depths=[3, 3, 27, 3],
        dims=[192, 384, 768, 1536]
    ),
    convnext_xlarge=dict(
        depths=[3, 3, 27, 3],
        dims=[256, 512, 1024, 2048]
    ),
)

def drop_path(inputs: tf.Tensor, drop_prob: float, is_training: bool) -> tf.Tensor:
    if (not is_training) or (drop_prob == 0.):
        return inputs

    keep_prob = 1.0 - drop_prob
    random_tensor = keep_prob

    shape = (tf.shape(inputs)[0],) + (1,) * (len(tf.shape(inputs)) - 1)

    random_tensor += tf.random.uniform(shape, dtype=inputs.dtype)
    binary_tensor = tf.floor(random_tensor)

    return tf.math.divide(inputs, keep_prob) * binary_tensor

class DropPath(tf.keras.layers.Layer):
    def __init__(self, drop_prob: float = None):
        super().__init__()

        self.drop_prob = drop_prob

    def call(self, x: tf.Tensor, training: bool = None):
        return drop_path(x, self.drop_prob, training)


class Block(tf.keras.layers.Layer):
    def __init__(self, dim: int, drop_path: float = 0., layer_scale_init_value: float = 1e-6, prefix: str = ''):
        super().__init__()

        self.dim = dim
        self.layer_scale_init_value = layer_scale_init_value
        self.prefix = prefix

        self.dwconv = tf.keras.layers.DepthwiseConv2D(kernel_size=7, padding='same')
        self.norm = tf.keras.layers.LayerNormalization(epsilon=1e-6)
        self.pwconv1 = tf.keras.layers.Dense(4 * dim)
        self.pwconv2 = tf.keras.layers.Dense(dim)
        self.drop_path = DropPath(drop_path)

        self.act = tf.keras.activations.gelu

    def build(self, input_shape: typing.Tuple[int]):
        self.gamma = tf.Variable(initial_value=self.layer_scale_init_value * tf.ones((self.dim)), trainable=True, name=f'{self.prefix}/gamma')
        self.built = True

    def call(self, x: tf.Tensor):
        input = x

        x = self.dwconv(x)
        x = self.norm(x)
        x = self.pwconv1(x)
        x = self.act(x)
        x = self.pwconv2(x)

        if self.gamma is not None:
            x = self.gamma * x

        x = input + self.drop_path(x)

        return x

class ConvNeXt(tf.keras.Model):
    def __init__(self, num_classes: int = 1000, depths: typing.List[int] = [3, 3, 9, 3], dims: typing.List[int] = [96, 192, 384, 768], include_top: bool = True, drop_path_rate: float = 0., layer_scale_init_value: float = 1e-6, head_init_scale: float = 1.,):
        super().__init__()
        
        self.include_top = include_top

        self.downsample_layers = [tf.keras.Sequential([tf.keras.layers.Conv2D(dims[0], kernel_size=4, strides=4, padding='same'), tf.keras.layers.LayerNormalization(epsilon=1e-6)])]

        for i in range(3):
            downsample_layer = tf.keras.Sequential([tf.keras.layers.LayerNormalization(epsilon=1e-6), tf.keras.layers.Conv2D(dims[i+1], kernel_size=2, strides=2, padding='same')])
            self.downsample_layers.append(downsample_layer)

        self.stages = []
        dp_rates = [x for x in np.linspace(0, drop_path_rate, sum(depths))]

        cur = 0
        for i in range(4):
            stage = tf.keras.Sequential([Block(dim=dims[i], drop_path=dp_rates[cur + j], layer_scale_init_value=layer_scale_init_value, prefix=f'block{i}') for j in range(depths[i])])
            self.stages.append(stage)
            
            cur += depths[i]

        if self.include_top:
            self.avg = tf.keras.layers.GlobalAveragePooling2D()
            self.norm = tf.keras.layers.LayerNormalization(epsilon = 1e-6)
            self.head = tf.keras.layers.Dense(num_classes)
        else:
            self.avg = None
            self.norm = None
            self.head = None

    def forward_features(self, x: tf.Tensor):
        for i in range(4):
            x = self.downsample_layers[i](x)
            x = self.stages[i](x)

        return x

    def call(self, x: tf.Tensor):
        x = self.forward_features(x)

        if self.include_top:
            x = self.avg(x)
            x = self.norm(x)
            x = self.head(x)

        return x

def load_model(model_name='convnext_tiny_1k', input_shape=(224, 224), num_classes=1000, include_top=True, pretrained=True, **kwargs):
    cfg = MODEL_CONFIG['_'.join(model_name.split('_')[:2])]

    net = ConvNeXt(num_classes, cfg['depths'], cfg['dims'], include_top, **kwargs)
    net(tf.keras.Input(shape=(*input_shape, 3)))

    if pretrained is True:
        url = MODEL_URLS[model_name]
        pretrained_ckpt = tf.keras.utils.get_file(f'{model_name}.h5', url, untar=False)
        net.load_weights(pretrained_ckpt, skip_mismatch=True, by_name=True)

    return net

class ConvNext(Model):
    INPUT_SIZE = (384, 384)
    INPUT_CHANNELS = 3
    ALLOW_RESIZE = False

    def __init__(self, num_classes: int) -> None:
        super().__init__()

        self.model = load_model(model_name='convnext_xlarge_384', input_shape=(384, 384), num_classes=num_classes, include_top=False)

    def call(self, input: tf.Tensor) -> tf.Tensor:
        return self.model(input)
