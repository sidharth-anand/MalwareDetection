import tensorflow as tf
import tensorflow_addons as tfa
import numpy as np

from core.model import Model

class MalConv(Model):
    def __init__(self, num_classes) -> None:
        super().__init__()

        emb_dim = 8
        channels = 128
        kernel = 512
        stride = 512

        self.chunk_size = 65536
        self.overlap = 512
        self.min_chunk_size = 1024
        self.receptive_field = None

        self.pooling = tfa.layers.AdaptiveMaxPooling1D(1)

        self.embedding = tf.keras.layers.Embedding(257, emb_dim, mask_zero=True)

        self.conv_1 = tf.keras.layers.Conv1D(channels, kernel, strides=stride)
        self.conv_2 = tf.keras.layers.Conv1D(channels, kernel, strides=stride)

        self.fc_1 = tf.keras.layers.Dense(channels)
        self.fc_2 = tf.keras.layers.Dense(num_classes)

    def _rf(self):
        min_rf = 1
        max_rf = self.chunk_size

        tmp = tf.zeros((1, max_rf), dtype=tf.int32)

        while True:
            test_size = (min_rf + max_rf) // 2
            is_valid = True

            try:
                self._process_range(tmp[:, :test_size])
            except:
                is_valid = False

            if is_valid:
                max_rf = test_size
            else:
                min_rf = test_size + 1

            if max_rf == min_rf:
                self.receptive_field = min_rf
                out_shape = self._process_range(tmp).shape
                self.stride = self.chunk_size // out_shape[2]
                self.out_channels = out_shape[1]
                break

        return self.receptive_field, self.stride, self.out_channels


    def _process_range(self, x):
        x = self.embedding(x)
        x = tf.transpose(x, perm=[0, -1, -2])
        
        cnn_value = self.conv_1(x)
        gating = tf.nn.sigmoid(self.conv_2(x))

        x = cnn_value * gating

        return x
    
    def seq2fix(self, x):
        receptive_window, stride, out_channels = self._rf()

        if x.shape[1] < receptive_window:
            x = tf.pad(x, [[0, 0], [0, receptive_window - x.shape[1]]])

        batch_size = x.shape[0]
        length = x.shape[1]

        winner_values = np.zeros((batch_size, out_channels)) - 1.
        winner_indices = np.zeros((batch_size, out_channels), dtype=np.int64)

        step = self.chunk_size
        start = 0
        end = start + step

        while start < end and (end - start) >= max(self.min_chunk_size, receptive_window):
            x_sub = x[:, start:end]
            activs = self._process_range(x_sub)
            activ_win, activ_indx = tf.nn.max_pool1d(activs, kernel_size=activs.shape[2])
            activ_win = activ_win.cpu().numpy()[:, :, 0]
            activ_indx = activ_indx.cpu().numpy()[:, :, 0]
            selected = winner_values < activ_win
            winner_indices[selected] = activ_indx[selected] * stride + start
            winner_values[selected] = activ_win[selected]
            start = end
            end = min(start + step, length)

        final_indices = [np.unique(winner_indices[b, :] for b in range(batch_size))]

        chunk_list = [[x[b:b+1,max(i-receptive_window,0):min(i+receptive_window,length)] for i in final_indices[b]] for b in range(batch_size)]
        chunk_list = [tf.concat(c, axis=1)[0,:] for c in chunk_list]

        x_selected = tf.keras.utils.pad_sequences(chunk_list)

        x_selected = self._process_range(x_selected)
        x_selected = self.pooling(x_selected)
        x_selected = x_selected.reshape((x_selected.shape[0], -1))

        return x_selected

    def call(self, x):
        x = self.seq2fix(x)
        x = tf.nn.relu(self.fc_1(x))
        x = self.fc_2(x)

        return x